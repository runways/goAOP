package aops

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/scanner"
	"go/token"
	"os"
	"strings"
)

// position Get all functions that need add AOP.
//
// Pkgs should generate by `parser.ParseDir` and `id` is the AOP middleware name, e.g. @trace.
//
// This function will ignore *_test.go. It will return a map(map[string][]string), key is file
// name, value is a function name array.
func position(pkgs map[string]*ast.Package, id string) map[string][]string {
	result := make(map[string][]string)

	for _, pack := range pkgs {
		for name, f := range pack.Files {
			if strings.HasSuffix(name, "_test.go") {
				continue
			}
			var functions []string
			for _, funDecl := range f.Decls {
				switch t := funDecl.(type) {
				case *ast.FuncDecl:
					if t.Doc != nil {
						for _, c := range t.Doc.List {
							if strings.Contains(c.Text, id) {
								functions = append(functions, t.Name.String())
							}
						}
					}
				}
			}
			if len(functions) > 0 {
				result[name] = functions
			}
		}
	}

	return result
}

// parserStmt Convert stmt to ast.Stmt
// If the stmt is a valid stmt, then return ast.Stmt.
// Otherwise, return a error.
func parserStmt(stmt string) (ast.Stmt, error) {
	expr := "func(){" + stmt + ";}"
	if e, err := parser.ParseExpr(expr); err != nil {
		if e, err := parser.ParseExpr(stmt); err == nil {
			return &ast.ExprStmt{X: e}, nil
		}
		errs := err.(scanner.ErrorList)
		for i := range errs {
			errs[i].Pos.Offset -= 7
			errs[i].Pos.Column -= 7
		}
		return nil, errs
	} else {
		node := e.(*ast.FuncLit).Body.List[0]
		if stmt, ok := node.(ast.Stmt); !ok {
			return nil, fmt.Errorf("%T not supported", node)
		} else {
			return stmt, nil
		}
	}
}

// addCode Insert AOP code to source code files.
// `pkgs` is map that save file name and function names.
// `pkgs` is generated by `position` function.
//
// funStmt is a string slice, that save function declare, e.g. `func(){}()`.
// Please attention, a simple `fun` declare does not have any effect, e.g. `func(){ fmt.Println() }`.
// If wants to execute this function, invoke function at the end, like `func(){}()`
//
// deferStmt is a string slice, that save defer function declare, e.g. `defer func(){}()`.
// When use deferStmt, please keep deferStmt valid.
//
// When adding code, it will add funStmt first, and add deferStmt by follow.
//
// Replace used to indicate replace source file or not. If replace == true, it replaces at the end.
// Otherwise, it will not.
func addCode(pkgs map[string][]string, funStmt, deferStmt []string, replace bool) error {
	exprs := make([]ast.Expr, len(funStmt))
	stmts := make([]ast.Stmt, len(deferStmt))
	for idx, c := range funStmt {
		exprInsert, err := parser.ParseExpr(c)
		if err != nil {
			return err
		}
		exprs[idx] = exprInsert
	}

	for idx, c := range deferStmt {
		stmtInsert, err := parserStmt(c)
		if err != nil {
			return err
		}
		stmts[idx] = stmtInsert
	}

	for name, funs := range pkgs {
		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, name, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		fm := make(map[string]interface{})
		for _, n := range funs {
			fm[n] = nil
		}

		decls := make([]ast.Decl, 0, len(f.Decls))
		for _, decl := range f.Decls {
			switch t := decl.(type) {
			case *ast.FuncDecl:
				if _, exist := fm[t.Name.Name]; exist {
					stats := make([]ast.Stmt, 0, len(t.Body.List)+len(exprs))

					for _, e := range exprs {
						stats = append(stats, &ast.ExprStmt{
							X: e,
						})
					}

					for _, e := range stmts {
						stats = append(stats, e)
					}

					stats = append(stats, t.Body.List...)
					t.Body.List = stats
				}
				decls = append(decls, t)
			default:
				decls = append(decls, t)
			}
		}
		f.Decls = decls

		var cfg printer.Config
		var buf bytes.Buffer

		cfg.Fprint(&buf, fset, f)

		dest, err := format.Source(buf.Bytes())
		if err != nil {
			return err
		}
		if replace {
			os.WriteFile(name, dest, 0777)
		} else {
			fmt.Println(string(dest))
		}
	}

	return nil
}
